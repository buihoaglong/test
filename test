-- Auto Collect Arrows (for Your Bizarre Adventure)
-- Tích hợp với Fluent UI; nếu bạn chưa load Fluent UI, script bên dưới sẽ load nó.
-- Dán chạy trong LocalScript / executor.

-- ==== CONFIG ====
local SCAN_PATHS = { "ItemSpawns", "Item_Spawns", "Item_Spawn", "ItemSpawns.Items", "Item_Spawns.Items" } 
-- tên folder có thể thay đổi; script sẽ tìm trong workspace các folder chứa "ItemSpawn" tương tự
local ITEM_KEYWORDS = { "arrow", "mysterious", "mystery" } -- các từ khóa để nhận diện item
local PICKUP_DISTANCE = 6         -- khoảng cách (studs) để gọi hành động nhặt
local MIN_TWEEN_DURATION = 0.4
local MAX_TWEEN_DURATION = 8
local SPEED_DIV = 80              -- điều chỉnh tốc độ: duration = distance / SPEED_DIV
local LOOP_DELAY = 0.5            -- delay giữa mỗi vòng tìm kiếm

-- ==== END CONFIG ====

local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Load Fluent (nếu chưa load)
local ok, Fluent = pcall(function()
    return loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
end)
if not ok or not Fluent then
    warn("Cannot load Fluent UI. Make sure executor has httpget enabled.")
    return
end

-- ====== UI: Thêm tab Auto Collect ======
local Window = Fluent:CreateWindow({
    Title = "Teleport Menu (YBA Tools)",
    SubTitle = "Fluent UI Example",
    TabWidth = 120,
    Size = UDim2.fromOffset(520, 400),
})

local Tab = Window:AddTab({ Title = "Teleport", Icon = "compass" })
-- (Bạn có thể giữ các nút Teleport/Fly hiện có ở đây)
-- Tạo tab Auto Collect mới
local AutoTab = Window:AddTab({ Title = "Auto Collect", Icon = "bolt" })

-- UI controls
local autoEnabled = false
local pickupDistance = PICKUP_DISTANCE
local speedDiv = SPEED_DIV
local loopDelay = LOOP_DELAY

AutoTab:AddLabel("Auto Collect: tìm & nhặt Arrow (YBA)")
local statusLabel = AutoTab:AddLabel("Status: OFF")

-- slider / inputs
local distanceSlider = AutoTab:AddSlider("PickupDistance", {
    Title = "Pickup distance",
    Min = 3,
    Max = 20,
    Value = pickupDistance,
    Callback = function(v) pickupDistance = v end,
})

local speedSlider = AutoTab:AddSlider("SpeedDiv", {
    Title = "Speed divisor (smaller = faster)",
    Min = 40,
    Max = 200,
    Value = speedDiv,
    Callback = function(v) speedDiv = v end,
})

local delaySlider = AutoTab:AddSlider("LoopDelay", {
    Title = "Loop delay (s)",
    Min = 0.1,
    Max = 2,
    Value = loopDelay,
    Callback = function(v) loopDelay = v end,
})

-- find candidate remote helpers
local function findCommonPromptRemote()
    -- returns function(remote, item) to call :FireServer(item)
    -- Try some common remote paths used in many games (including YBA typical names)
    local tries = {}

    -- try ReplicatedStorage.Remotes.PromptModule.Prompt
    local ok, r = pcall(function() return ReplicatedStorage:WaitForChild("Remotes") end)
    if ok and r then
        local function tryPath(root, pathParts)
            local cur = root
            for _, part in ipairs(pathParts) do
                cur = cur and cur:FindFirstChild(part)
                if not cur then return nil end
            end
            return cur
        end

        local possible = {
            {"PromptModule", "Prompt"},
            {"Prompt",},
            {"ItemPrompt",},
            {"Pickup",},
            {"PickupItem",},
            {"PromptService", "Prompt"},
        }
        for _, p in ipairs(possible) do
            local rem = tryPath(r, p)
            if rem and rem.FireServer then
                return rem
            end
        end
    end

    -- try top-level ReplicatedStorage Prompt-ish
    local altNames = {"Prompt", "ItemPickup", "ItemSpawn", "Pickup"}
    for _, name in ipairs(altNames) do
        local rem = ReplicatedStorage:FindFirstChild(name)
        if rem and rem.FireServer then
            return rem
        end
    end

    -- not found
    return nil
end

local promptRemote = findCommonPromptRemote()
if promptRemote then
    print("AutoCollect: Found prompt remote:", promptRemote:GetFullName())
else
    print("AutoCollect: No common prompt remote found automatically. Pickup may still work by proximity.")
end

-- helper: find items by scanning workspace for likely item containers
local function getItemContainers()
    local results = {}
    for _, child in ipairs(workspace:GetDescendants()) do
        if child:IsA("Folder") or child:IsA("Model") then
            local nm = string.lower(child.Name)
            for _, pat in ipairs(SCAN_PATHS) do
                if nm == string.lower(pat) or string.find(nm, string.lower("item")) then
                    -- add unique parent containers like workspace.ItemSpawns, workspace.Item_Spawns.Items, etc.
                    if not table.find(results, child) then
                        table.insert(results, child)
                    end
                end
            end
        end
    end
    -- also try direct known path
    local direct = workspace:FindFirstChild("ItemSpawns") or workspace:FindFirstChild("Item_Spawns") or workspace:FindFirstChild("Item_Spawn")
    if direct and not table.find(results, direct) then table.insert(results, direct) end
    return results
end

-- helper: check if a model/part looks like arrow using keywords
local function isLikelyArrow(inst)
    if not inst then return false end
    local name = string.lower(inst.Name or "")
    for _, kw in ipairs(ITEM_KEYWORDS) do
        if string.find(name, kw) then return true end
    end
    -- sometimes the model has child named "Handle" or "PrimaryPart" with those names
    for _, c in ipairs(inst:GetChildren()) do
        if c:IsA("BasePart") then
            local cn = string.lower(c.Name)
            for _, kw in ipairs(ITEM_KEYWORDS) do
                if string.find(cn, kw) then return true end
            end
        end
    end
    return false
end

-- find all candidate item instances (BasePart or Model with PrimaryPart/Handle)
local function findAllItems()
    local found = {}
    -- scan common containers first
    local containers = getItemContainers()
    for _, cont in ipairs(containers) do
        for _, child in ipairs(cont:GetDescendants()) do
            if child and child.Parent then
                if child:IsA("Model") and isLikelyArrow(child) then
                    table.insert(found, child)
                elseif child:IsA("BasePart") and isLikelyArrow(child) then
                    table.insert(found, child)
                end
            end
        end
    end

    -- fallback: full workspace scan (costly, but last resort)
    if #found == 0 then
        for _, child in ipairs(workspace:GetDescendants()) do
            if child:IsA("Model") and isLikelyArrow(child) then
                table.insert(found, child)
            elseif child:IsA("BasePart") and isLikelyArrow(child) then
                table.insert(found, child)
            end
        end
    end
    return found
end

-- get position of an item (Model or Part)
local function getItemPosition(item)
    if not item then return nil end
    if item:IsA("BasePart") then
        return item.Position
    elseif item:IsA("Model") then
        if item.PrimaryPart then return item.PrimaryPart.Position end
        local handle = item:FindFirstChild("Handle") or item:FindFirstChildWhichIsA("BasePart")
        if handle then return handle.Position end
    end
    return nil
end

-- attempt to "pickup" the item using several methods
local function attemptPickup(item)
    if not item then return false end
    -- 1) If we found a prompt remote earlier, try FireServer(item)
    if promptRemote and pcall(function() promptRemote:FireServer(item) end) then
        return true
    end

    -- 2) Try to fire common remote paths directly if exist
    local function tryPath(root, parts)
        local cur = root
        for _, p in ipairs(parts) do
            cur = cur and cur:FindFirstChild(p)
            if not cur then return nil end
        end
        return cur
    end

    local tryRemotes = {
        {ReplicatedStorage, {"Remotes", "PromptModule", "Prompt"}},
        {ReplicatedStorage, {"Remotes", "Prompt"}},
        {ReplicatedStorage, {"Prompt"}},
        {ReplicatedStorage, {"ItemPickup"}},
    }
    for _, path in ipairs(tryRemotes) do
        local r = tryPath(path[1], path[2])
        if r and r.FireServer then
            pcall(function() r:FireServer(item) end)
            return true
        end
    end

    -- 3) If item has a ProximityPrompt, try to :InputHoldBegin or :Trigger (client-side)
    local primary = item:IsA("BasePart") and item or (item.PrimaryPart or item:FindFirstChild("Handle") or item:FindFirstChildWhichIsA("BasePart"))
    if primary then
        for _, pp in ipairs(primary:GetDescendants()) do
            if pp:IsA("ProximityPrompt") then
                -- try :InputHoldBegin / :InputHoldEnd if available, else :Trigger (some executors provide :Trigger)
                pcall(function()
                    if pp.Trigger then
                        pp:Trigger()
                    elseif pp.HoldBegin then
                        pp:InputHoldBegin()
                        wait(0.2)
                        pp:InputHoldEnd()
                    else
                        -- fallback: fire prompt on server side if bound
                        if promptRemote and promptRemote.FireServer then
                            promptRemote:FireServer(item)
                        end
                    end
                end)
                return true
            end
        end
    end

    -- 4) fallback: move to item and wait a moment; some games auto pickup on proximity
    return false
end

-- tween HRP to targetPosition (with clamped duration)
local function tweenToPosition(hrp, targetPos)
    if not hrp then return end
    local distance = (hrp.Position - targetPos).Magnitude
    local duration = math.clamp(distance / speedDiv, MIN_TWEEN_DURATION, MAX_TWEEN_DURATION)
    local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
    local success, err = pcall(function()
        local t = TweenService:Create(hrp, tweenInfo, { CFrame = CFrame.new(targetPos) })
        t:Play()
        t.Completed:Wait()
    end)
    if not success then
        -- fallback: set CFrame
        pcall(function() hrp.CFrame = CFrame.new(targetPos) end)
    end
end

-- main auto collect loop
local collecting = false
local function autoCollectLoop()
    if collecting then return end
    collecting = true
    statusLabel:Set("Status: RUNNING")
    while autoEnabled do
        -- get character
        local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local hrp = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso") or char:FindFirstChildWhichIsA("BasePart")
        if not hrp then
            wait(0.5)
            continue
        end

        local items = findAllItems()
        if #items == 0 then
            -- nothing found: short wait then continue
            wait(loopDelay)
            continue
        end

        -- map to positions and choose nearest valid
        local nearest = nil
        local nearestDist = math.huge
        for _, it in ipairs(items) do
            local pos = getItemPosition(it)
            if pos then
                local d = (hrp.Position - pos).Magnitude
                if d < nearestDist then
                    nearestDist = d
                    nearest = it
                end
            end
        end

        if nearest and nearest.Parent then
            local pos = getItemPosition(nearest)
            if pos then
                -- if already within pickupDistance, just try pickup directly
                if nearestDist <= pickupDistance then
                    local ok = pcall(function() attemptPickup(nearest) end)
                    if ok then
                        -- quick small wait to allow server process
                        wait(0.4)
                    end
                else
                    -- tween to above the item (a little offset in Y)
                    local targetPos = pos + Vector3.new(0, 3, 0)
                    tweenToPosition(hrp, targetPos)
                    -- after tween, attempt pickup
                    attemptPickup(nearest)
                    wait(0.2)
                end
            end
        end

        wait(loopDelay)
    end
    statusLabel:Set("Status: OFF")
    collecting = false
end

-- Toggle Button
AutoTab:AddToggle("AutoCollectToggle", {
    Title = "Auto Collect On/Off",
    Default = false,
    Callback = function(v)
        autoEnabled = v
        if autoEnabled then
            -- refresh promptRemote (in case remote appears later)
            promptRemote = findCommonPromptRemote()
            statusLabel:Set("Status: STARTING")
            spawn(function() autoCollectLoop() end)
        else
            statusLabel:Set("Status: OFF")
        end
    end,
})

AutoTab:AddButton({
    Title = "Refresh Item List (manual)",
    Callback = function()
        local items = findAllItems()
        local names = {}
        for _, it in ipairs(items) do
            table.insert(names, it:GetFullName().." ["..tostring(getItemPosition(it) or "nil").."]")
        end
        if #names == 0 then
            Fluent:Notify({ Title = "Refresh", Content = "No items found.", Duration = 2 })
        else
            Fluent:Notify({ Title = "Refresh", Content = "Found " .. #names .. " possible items. Check console for list.", Duration = 3 })
            for _, n in ipairs(names) do print(n) end
        end
    end,
})

-- ========== Mobile-friendly toggle UI (nhỏ gọn) ==========
do
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "FluentUIToggler"
    ScreenGui.Parent = game.CoreGui
    ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

    local ToggleButton = Instance.new("TextButton")
    ToggleButton.Parent = ScreenGui
    ToggleButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    ToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    ToggleButton.Text = "UI"
    ToggleButton.Font = Enum.Font.GothamBold
    ToggleButton.TextSize = 18
    ToggleButton.Size = UDim2.new(0, 60, 0, 30)
    ToggleButton.Position = UDim2.new(1, -70, 1, -40)
    ToggleButton.BorderSizePixel = 0
    ToggleButton.Active = true
    ToggleButton.Draggable = true

    ToggleButton.MouseButton1Click:Connect(function()
        local fluentGui = game.CoreGui:FindFirstChild("Fluent")
        if fluentGui then
            fluentGui.Enabled = not fluentGui.Enabled
            ToggleButton.Text = fluentGui.Enabled and "Hide" or "Show"
        end
    end)
end

-- final notify
Fluent:Notify({ Title = "AutoCollect Loaded", Content = "Auto Collect module loaded. Open 'Auto Collect' tab.", Duration = 3 })

